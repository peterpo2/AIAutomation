import OpenAI from 'openai';
import { prisma } from '../auth/prisma.client.js';

export class AutomationError extends Error {
  readonly status: number;
  readonly details?: unknown;

  constructor(message: string, status = 500, details?: unknown) {
    super(message);
    this.name = 'AutomationError';
    this.status = status;
    this.details = details;
  }
}

export interface AutomationNodeDefinition {
  code: string;
  step: string;
  title: string;
  description: string;
  function: string;
  aiAssist: string;
  status: 'operational' | 'monitor' | 'upcoming';
  statusLabel: string;
  sequence: number;
  dependencies: string[];
  deliverables: string[];
  webhookPath: string;
}

export interface AutomationNodeView extends Omit<AutomationNodeDefinition, 'webhookPath'> {
  webhookPath: string;
  webhookUrl: string | null;
  connected: boolean;
  position?: { x: number; y: number } | null;
  positionX?: number | null;
  positionY?: number | null;
  layout?: { x: number; y: number } | null;
}

export interface AutomationRunResult {
  code: string;
  ok: boolean;
  httpStatus: number | null;
  statusText: string | null;
  webhookUrl: string | null;
  startedAt: string;
  finishedAt: string;
  durationMs: number;
  requestPayload: unknown;
  responseBody: unknown;
  responseHeaders: Record<string, string>;
  error?: string;
}

const automationNodes: AutomationNodeDefinition[] = [
  {
    code: 'CCC',
    step: 'Content Calendar Creation',
    title: 'AI Content Planner',
    description: 'Inputs briefs and brand data to propose a weekly narrative arc with per-platform messaging.',
    function: 'Generates channel-ready post calendars and creative prompts.',
    aiAssist: 'Strategic ideation using OpenAI for voice, hooks, and CTA matching.',
    status: 'operational',
    statusLabel: 'Live · Updated daily with the latest briefs.',
    sequence: 1,
    dependencies: [],
    deliverables: ['Campaign calendar', 'Concept moodboard', 'Copy angle matrix'],
    webhookPath: '/workflow/ccc',
  },
  {
    code: 'VPE',
    step: 'Video Production & Editing',
    title: 'Hybrid Video Team',
    description: 'Pairs human editors with the AI caption assistant to accelerate turnaround.',
    function: 'Produces ready-to-upload clips with optimized captions and aspect ratios.',
    aiAssist: 'Caption drafts and hook variations are generated via OpenAI for review.',
    status: 'operational',
    statusLabel: 'On track · Average turnaround 6h.',
    sequence: 2,
    dependencies: ['CCC'],
    deliverables: ['Edited video masters', 'Auto-caption files', 'Thumbnail concepts'],
    webhookPath: '/workflow/vpe',
  },
  {
    code: 'USP',
    step: 'Upload Schedule Planning',
    title: 'Scheduler Engine',
    description: 'Analyses engagement trends to propose optimal posting windows across markets.',
    function: 'Calculates best publish times per asset and queues reminders.',
    aiAssist: 'OpenAI summarises engagement anomalies and suggests experiments.',
    status: 'monitor',
    statusLabel: 'Monitoring · Needs fresh engagement dataset.',
    sequence: 3,
    dependencies: ['VPE'],
    deliverables: ['Posting matrix', 'Audience overlap report'],
    webhookPath: '/workflow/usp',
  },
  {
    code: 'UMS',
    step: 'Upload Management System',
    title: 'Content Manager Module',
    description: 'Securely stores final assets with captions and metadata ready for deployment.',
    function: 'Maintains the upload queue and version control for creative assets.',
    aiAssist: 'Metadata validation and tone checks executed with OpenAI.',
    status: 'operational',
    statusLabel: 'Stable · Queue capacity at 68%.',
    sequence: 4,
    dependencies: ['USP'],
    deliverables: ['Upload-ready bundles', 'Metadata QA checklist'],
    webhookPath: '/workflow/ums',
  },
  {
    code: 'AL',
    step: 'Account Linking',
    title: 'TikTok Auth Connector',
    description: 'Handles OAuth 2.0 and token storage per client workspace.',
    function: 'Ensures tokens are refreshed and scoped correctly for publishing.',
    aiAssist: 'OpenAI drafts security notifications and scope explanations.',
    status: 'operational',
    statusLabel: 'Healthy · Tokens refreshed automatically.',
    sequence: 5,
    dependencies: ['UMS'],
    deliverables: ['Active OAuth tokens', 'Security audit logs'],
    webhookPath: '/workflow/al',
  },
  {
    code: 'AR',
    step: 'Automation Rules',
    title: 'Workflow Automation Engine',
    description: 'Evaluates triggers, fallbacks, and notifications before pushing to runtime.',
    function: 'Determines upload eligibility, handles retries, and routes alerts.',
    aiAssist: 'Anomaly narratives and post-mortems generated by OpenAI.',
    status: 'monitor',
    statusLabel: 'Monitoring · Reviewing recent retry spikes.',
    sequence: 6,
    dependencies: ['AL'],
    deliverables: ['Rule manifests', 'Escalation briefs'],
    webhookPath: '/workflow/ar',
  },
  {
    code: 'WAU',
    step: 'Weekly Auto Uploads',
    title: 'Scheduler Runtime Node',
    description: 'Executes scheduled posts via the TikTok API with health checks.',
    function: 'Publishes approved assets and tracks outcome confirmations.',
    aiAssist: 'OpenAI crafts failure remediation guidance for the ops team.',
    status: 'monitor',
    statusLabel: 'Monitoring · Awaiting green-light from Automation Rules.',
    sequence: 7,
    dependencies: ['AR'],
    deliverables: ['Deployment receipts', 'Fallback queue status'],
    webhookPath: '/workflow/wau',
  },
  {
    code: 'MAO',
    step: 'Monitoring & Optimization',
    title: 'Analytics Engine',
    description: 'Collects performance metrics and distributes actionable intelligence.',
    function: 'Generates weekly optimisation reports and experimentation prompts.',
    aiAssist: 'Insight summaries, next-best-actions, and scripts are authored with OpenAI.',
    status: 'upcoming',
    statusLabel: 'Scheduled · Next sync Friday 09:00.',
    sequence: 8,
    dependencies: ['WAU'],
    deliverables: ['Performance dashboard', 'Optimisation brief'],
    webhookPath: '/workflow/mao',
  },
];

const resolveN8nBaseUrl = (): string | null => {
  const raw = process.env.N8N_BASE_URL;
  if (!raw || raw.trim().length === 0) {
    return null;
  }

  const normalized = raw.trim().endsWith('/') ? raw.trim() : `${raw.trim()}/`;
  return normalized;
};

const resolveWebhookUrl = (path: string): string | null => {
  const base = resolveN8nBaseUrl();
  if (!base) {
    return null;
  }

  try {
    const normalizedPath = path.startsWith('/') ? path.slice(1) : path;
    return new URL(normalizedPath, base).toString();
  } catch (error) {
    console.error('Failed to resolve n8n webhook URL', error);
    return null;
  }
};

const resolveBasicAuthHeader = (): string | null => {
  const active = `${process.env.N8N_BASIC_AUTH_ACTIVE ?? ''}`.toLowerCase() === 'true';
  if (!active) {
    return null;
  }

  const user = process.env.N8N_BASIC_AUTH_USER;
  const password = process.env.N8N_BASIC_AUTH_PASSWORD;

  if (!user || !password) {
    console.warn('n8n basic auth is marked active, but credentials are missing. Skipping Authorization header.');
    return null;
  }

  const token = Buffer.from(`${user}:${password}`).toString('base64');
  return `Basic ${token}`;
};

const serializePayload = (payload: unknown): string | undefined => {
  if (payload === undefined) {
    return undefined;
  }

  try {
    return JSON.stringify(payload);
  } catch (error) {
    throw new AutomationError('Unable to serialise the provided payload for the n8n webhook.', 400, {
      cause: error instanceof Error ? error.message : 'Unknown serialization error',
    });
  }
};

const getOpenAIClient = () => {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error('OPENAI_API_KEY missing');
  }
  return new OpenAI({ apiKey });
};

export const automationsService = {
  async listNodes(userId?: string | null): Promise<AutomationNodeView[]> {
    let layoutMap = new Map<string, { x: number; y: number }>();

    if (userId) {
      try {
        const layouts = await prisma.automationLayout.findMany({
          where: { userId },
        });
        layoutMap = new Map(
          layouts.map((layout) => [
            layout.automationCode,
            { x: layout.positionX, y: layout.positionY },
          ]),
        );
      } catch (error) {
        console.error('Failed to load automation layouts for user', userId, error);
      }
    }

    return automationNodes.map((node) => {
      const webhookUrl = resolveWebhookUrl(node.webhookPath);
      const savedPosition = layoutMap.get(node.code) ?? null;

      return {
        ...node,
        webhookUrl,
        connected: Boolean(webhookUrl),
        position: savedPosition,
        positionX: savedPosition?.x ?? null,
        positionY: savedPosition?.y ?? null,
        layout: savedPosition,
      } satisfies AutomationNodeView;
    });
  },

  async saveNodePosition({
    userId,
    code,
    position,
  }: {
    userId: string;
    code: string;
    position: { x: number; y: number };
  }): Promise<void> {
    const normalizedCode = code.toUpperCase();
    const node = automationNodes.find((candidate) => candidate.code === normalizedCode);

    if (!node) {
      throw new AutomationError(`Automation node ${normalizedCode} was not found.`, 404);
    }

    try {
      await prisma.automationLayout.upsert({
        where: {
          userId_automationCode: {
            userId,
            automationCode: normalizedCode,
          },
        },
        update: {
          positionX: position.x,
          positionY: position.y,
        },
        create: {
          userId,
          automationCode: normalizedCode,
          positionX: position.x,
          positionY: position.y,
        },
      });
    } catch (error) {
      console.error('Failed to persist automation layout for user', userId, normalizedCode, error);
      throw new AutomationError('Unable to save automation layout.', 500);
    }
  },

  async runNode({ code, payload }: { code: string; payload?: unknown }): Promise<AutomationRunResult> {
    const normalizedCode = code.toUpperCase();
    const definition = automationNodes.find((node) => node.code === normalizedCode);

    if (!definition) {
      throw new AutomationError(`Automation node ${normalizedCode} was not found.`, 404);
    }

    const webhookUrl = resolveWebhookUrl(definition.webhookPath);

    if (!webhookUrl) {
      throw new AutomationError(
        'n8n base URL is not configured. Set N8N_BASE_URL so SmartOps can reach the workflow webhooks.',
        503,
      );
    }

    const body = serializePayload(payload);
    const startedAt = new Date();
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };

    const authHeader = resolveBasicAuthHeader();
    if (authHeader) {
      headers.Authorization = authHeader;
    }

    let response: Response | null = null;

    try {
      response = await fetch(webhookUrl, {
        method: 'POST',
        headers,
        body,
      });
    } catch (error) {
      const finishedAt = new Date();
      return {
        code: definition.code,
        ok: false,
        httpStatus: null,
        statusText: 'FETCH_ERROR',
        webhookUrl,
        startedAt: startedAt.toISOString(),
        finishedAt: finishedAt.toISOString(),
        durationMs: finishedAt.getTime() - startedAt.getTime(),
        requestPayload: payload ?? null,
        responseBody: null,
        responseHeaders: {},
        error: error instanceof Error ? error.message : 'Unknown error contacting n8n webhook.',
      };
    }

    const finishedAt = new Date();

    const headersRecord: Record<string, string> = {};
    response.headers.forEach((value, key) => {
      headersRecord[key] = value;
    });

    let responseBody: unknown = null;
    const contentType = response.headers.get('content-type') ?? '';

    if (contentType.includes('application/json')) {
      responseBody = await response.json().catch(() => null);
    } else {
      const text = await response.text().catch(() => null);
      responseBody = text && text.length > 0 ? text : null;
    }

    const result: AutomationRunResult = {
      code: definition.code,
      ok: response.ok,
      httpStatus: response.status,
      statusText: response.statusText || null,
      webhookUrl,
      startedAt: startedAt.toISOString(),
      finishedAt: finishedAt.toISOString(),
      durationMs: finishedAt.getTime() - startedAt.getTime(),
      requestPayload: payload ?? null,
      responseBody,
      responseHeaders: headersRecord,
    };

    if (!response.ok) {
      result.error = `n8n responded with status ${response.status}`;
    }

    return result;
  },

  async generateInsights({ focus }: { focus?: string }) {
    try {
      const openai = getOpenAIClient();
      const response = await openai.responses.create({
        model: 'gpt-4.1-mini',
        input: [
          {
            role: 'system',
            content:
              'You are an automation strategist for a creative agency. Provide concise, high-impact recommendations referencing the workflow nodes when relevant. Respond using markdown with short sections.',
          },
          {
            role: 'user',
            content: `Workflow nodes: ${automationNodes
              .map((node) => `${node.code} – ${node.title}: ${node.statusLabel}`)
              .join('; ')}. Focus on ${focus ?? 'overall pipeline performance'} and surface the next best actions, risk watchouts, and opportunities for OpenAI augmentation.`,
          },
        ],
      });

      if (response.output_text) {
        return response.output_text;
      }

      return 'Insights are not available at the moment. Please try again shortly.';
    } catch (error) {
      console.error('Failed to generate automation insights', error);
      return 'Insights are currently unavailable. Verify the OpenAI configuration and try again.';
    }
  },
};
